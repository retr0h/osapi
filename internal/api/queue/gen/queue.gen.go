// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// QueueItemResponse defines model for QueueItemResponse.
type QueueItemResponse struct {
	// Body Base64-encoded representation of the body of the queue item.
	Body *[]byte `json:"body,omitempty"`

	// Created Creation timestamp of the queue item.
	Created *time.Time `json:"created,omitempty"`

	// Id Unique identifier of the queue item.
	Id *string `json:"id,omitempty"`

	// Received Number of times the queue item has been received.
	Received *int `json:"received,omitempty"`

	// Timeout Timeout timestamp for the queue item.
	Timeout *time.Time `json:"timeout,omitempty"`

	// Updated Last updated timestamp of the queue item.
	Updated *time.Time `json:"updated,omitempty"`
}

// QueueResponse defines model for QueueResponse.
type QueueResponse struct {
	Items *[]QueueItemResponse `json:"items,omitempty"`

	// TotalItems The total number of queue items.
	TotalItems *int `json:"total_items,omitempty"`
}

// QueueStatusResponse defines model for QueueStatusResponse.
type QueueStatusResponse struct {
	// TotalItems The total number of items in the queue.
	TotalItems *int `json:"total_items,omitempty"`
}

// QueueErrorResponse defines model for queue.ErrorResponse.
type QueueErrorResponse struct {
	// Code The error code.
	Code int `json:"code"`

	// Details Additional details about the error, specifying which component failed.
	Details *string `json:"details,omitempty"`

	// Error A description of the error that occurred.
	Error string `json:"error"`
}

// GetQueueParams defines parameters for GetQueue.
type GetQueueParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostQueueJSONBody defines parameters for PostQueue.
type PostQueueJSONBody struct {
	// Body Base64-encoded representation of the body of the queue item.
	Body []byte `json:"body"`
}

// PostQueueJSONRequestBody defines body for PostQueue for application/json ContentType.
type PostQueueJSONRequestBody PostQueueJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all queue items
	// (GET /queue)
	GetQueue(ctx echo.Context, params GetQueueParams) error
	// Add an item to the queue
	// (POST /queue)
	PostQueue(ctx echo.Context) error
	// Returns the total number of items in the queue
	// (GET /queue/status)
	GetQueueStatus(ctx echo.Context) error
	// Delete a queue item by ID
	// (DELETE /queue/{id})
	DeleteQueueID(ctx echo.Context, id string) error
	// Get a queue item by ID
	// (GET /queue/{id})
	GetQueueID(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetQueue converts echo context to params.
func (w *ServerInterfaceWrapper) GetQueue(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQueueParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQueue(ctx, params)
	return err
}

// PostQueue converts echo context to params.
func (w *ServerInterfaceWrapper) PostQueue(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostQueue(ctx)
	return err
}

// GetQueueStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetQueueStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQueueStatus(ctx)
	return err
}

// DeleteQueueID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteQueueID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteQueueID(ctx, id)
	return err
}

// GetQueueID converts echo context to params.
func (w *ServerInterfaceWrapper) GetQueueID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQueueID(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/queue", wrapper.GetQueue)
	router.POST(baseURL+"/queue", wrapper.PostQueue)
	router.GET(baseURL+"/queue/status", wrapper.GetQueueStatus)
	router.DELETE(baseURL+"/queue/:id", wrapper.DeleteQueueID)
	router.GET(baseURL+"/queue/:id", wrapper.GetQueueID)

}
